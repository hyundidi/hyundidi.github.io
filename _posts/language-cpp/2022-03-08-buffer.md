---
title:  "입출력 버퍼와 endl 속도"
excerpt: "왜 \n 대신 endl을 사용하면 시간초과가 날까?"

categories:
  - Cpp
tags:
  - [c++, Buffer]

toc: true
toc_sticky: true
 
date: 2022-03-08
last_modified_at: 2022-03-08
---

알고리즘 문제풀이 중 모범답안과 로직은 똑같은데 내 풀이는 계속 시간초과가 나서 한참을 헤메다가 찾은 범인은 `endl` !!!  
`endl`을 `\n`으로 바꿨더니 똑같은 코드가 통과를 했다 😱

이유는 endl의 동작 방식에 있었다.

결론부터 말하자면 `endl`은 출력 후에 **버퍼를 비우는 동작**(flush)을 하기 때문에 `\n`보다 느리다


대충 느낌만 알고있던 버퍼 개념을 다시 한 번 정리해보기로 했다.  

## 입출력 버퍼 
![bufffer](https://user-images.githubusercontent.com/48314521/157240726-47b69682-b3b5-43e1-bc8a-fb5dad5c7352.png)

버퍼는 '임시 저장 공간'이다.

버퍼를 사용한 입출력은 입출력 문자를 모아두었다가 한번에 처리하는 방식이다. 입출력을 1바이트씩 계속 처리한다면 매번 데이터를 처리해야하므로 cpu사용 및 메모리 접근 횟수가 많아진다. 버퍼를 사용하면 데이터를 한번에 처리하기 때문에 효율적이다.

#### 버퍼를 비운다는 것의 의미

- 표준 입력 : 입력되는 문자를 입력 버퍼에 저장했다가 엔터 키`\n`가 입력되면 지정된 변수(배열, 할당한 메모리)로 옮기고 이 때 버퍼가 비워진다. 
- 표준 출력 : 출력 버퍼에 문자가 저장되었다가 특정 조건에 의해 **버퍼가 비워지면 화면에 출력**된다.

[🔗C 입출력 버퍼](https://dojang.io/mod/page/view.php?id=763)

---
다시 `endl`과 `\n`으로 돌아와서 코드를 통해 비교해보자.

## endl과 \n

```c++
#include <iostream>
#include <unistd.h> 
//window에서는 windows.h를 include해야 sleep()을 사용 할 수 있다.

using namespace std;
int main(void)
{
    cout << "hello" << endl;
    sleep(3);
    cout << "bye";
    return (0);
}
```
_hello_ 출력 3초 후 _bye_ 가 출력된다.
`endl`이 버퍼를 비우는 동작을 하기 때문에 sleep() 이전에 hello가 출력이 된다.

```c++
int main(void)
{
    cout << "hello";
    sleep(3);
    cout << "bye";
    return (0);
}
```
_hellobye_ 가 컴파일 3초 후 같이 출력된다.






---

### 충격적인 속도 테스트
시간초과가 났던 문제와 동일한 상황을 만들어 최대 200만번 string 출력 상황을 재현했는데..


```c++
#include <iostream>
#include <time.h>

using namespace std;
int main(void)
{
    
    int t;
    clock_t start, end;
    char* a = new char[20];
    strcpy(a, "abdefghijklmnopqrs");

    t=2000000;
    start = clock(); 
    while(t--) cout << a << endl;
    end = clock();
    double t1 = (double)(end - start)/CLOCKS_PER_SEC;

    t=2000000;
    start = clock();
    while(t--) cout << a << "\n";
    end = clock();
    double t2 = (double)(end - start)/CLOCKS_PER_SEC;

    t=2000000;
    start = clock();
    while(t--) printf("%s\n",a);
    end = clock();
    double t3 = (double)(end - start)/CLOCKS_PER_SEC;

    printf("\nTime1: %lf\nTime2: %lf\nTime3: %lf\n", t1,t2,t3);

    return 0;
}
```

결과가 너무 충격적이다😱😱😱😱
왜! `cout << a << endl;`이게 제일 빠르지?  
~~초등학교때 과학실험 생각난다. 이론 공부 열심히 하고 막상 실험하면 이상한 결과가 나와서 보고서 조작많이 했는데...~~  
무엇이 잘못됬는지 알려주실 분~!!
```
Time1: 1.322699     //cout << a << endl;
Time2: 1.372523     //cout << a << "\n";
Time3: 1.409360     //printf("%s\n",a);
```

공부하고도 찝찝해..!😩


### 결론
웬만하면 printf하자~!